
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOSI - Aquaponics Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .sensor-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 5px solid #667eea;
        }

        .sensor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .sensor-card.ph { border-left-color: #FF6B6B; }
        .sensor-card.do { border-left-color: #4ECDC4; }
        .sensor-card.ec { border-left-color: #45B7D1; }
        .sensor-card.tds { border-left-color: #FFA07A; }
        .sensor-card.temp { border-left-color: #FFD93D; }

        .sensor-name {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sensor-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .sensor-unit {
            font-size: 0.9em;
            color: #999;
        }

        .sensor-status {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-good { color: #27AE60; }
        .status-warning { color: #F39C12; }
        .status-danger { color: #E74C3C; }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-analyze {
            background: white;
            color: #667eea;
            flex: 1;
            min-width: 200px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            border: 3px solid #764ba2;
        }

        .btn-analyze:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            background: #f0f4ff;
        }

        .btn-predict {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
            min-width: 200px;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            border: 3px solid #667eea;
        }

        .btn-predict:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: #000;
        }

        .modal-header {
            margin-bottom: 25px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 15px;
        }

        .modal-header h2 {
            color: #333;
            margin-bottom: 5px;
        }

        .modal-header p {
            color: #666;
            font-size: 0.9em;
        }

        .concept {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
        }

        .concept h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .concept p {
            color: #666;
            line-height: 1.6;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 25px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .data-table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        /* Analysis Modal */
        .analysis-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .analysis-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .analysis-table td {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }

        .analysis-table tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-good {
            background: #D4EDDA;
            color: #155724;
        }

        .badge-warning {
            background: #FFF3CD;
            color: #856404;
        }

        .badge-danger {
            background: #F8D7DA;
            color: #721C24;
        }

        .recommendation {
            background: #E7F3FF;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #45B7D1;
            color: #0C5460;
            font-size: 0.9em;
            line-height: 1.6;
        }

        /* Enhanced Prediction Styles */
        .prediction-summary-stats {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .summary-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .summary-item h4 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.1em;
        }

        .summary-item p {
            margin: 5px 0;
            color: #666;
            font-size: 0.9em;
        }

        .trend-increasing {
            color: #E74C3C;
            font-weight: bold;
        }

        .trend-decreasing {
            color: #3498DB;
            font-weight: bold;
        }

        .trend-stable {
            color: #27AE60;
            font-weight: bold;
        }

        .prediction-value {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .prediction-value.status-good {
            color: #27AE60;
            background: #D5E8D5;
        }

        .prediction-value.status-warning {
            color: #F39C12;
            background: #FCF3CF;
        }

        .prediction-value.status-danger {
            color: #E74C3C;
            background: #F8D7DA;
        }

        #errorMessage {
            background: #F8D7DA;
            color: #721C24;
            padding: 20px;
            border-radius: 10px;
            white-space: pre-line;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }


        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .dashboard {
                grid-template-columns: 1fr;
            }

            .modal-content {
                width: 95%;
                margin: 20% auto;
            }

            .controls {
                flex-direction: column;
            }

            .btn-analyze {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üêü TOSI Aquaponics - C√° Ch√©p</h1>
            <p>H·ªá th·ªëng gi√°m s√°t c·∫£m bi·∫øn th·ªùi gian th·ª±c cho nu√¥i C√° Ch√©p</p>
        </div>

        <div class="controls">
            <button class="btn btn-analyze" onclick="showAnalysis()">üìä Ph√¢n T√≠ch H·ªá Th·ªëng</button>
            <button class="btn btn-predict" onclick="showPrediction()">üîÆ D·ª± ƒêo√°n Th√¥ng S·ªë</button>
        </div>

        <div class="dashboard">
            <div class="sensor-card ph" onclick="showSensorDetail('ph')">
                <div class="sensor-name">pH</div>
                <div class="sensor-value" id="phValue">--</div>
                <div class="sensor-unit">ƒê·ªô axit/ki·ªÅm</div>
                <div class="sensor-status" id="phStatus">--</div>
            </div>

            <div class="sensor-card do" onclick="showSensorDetail('do')">
                <div class="sensor-name">DO</div>
                <div class="sensor-value" id="doValue">--</div>
                <div class="sensor-unit">mg/L</div>
                <div class="sensor-status" id="doStatus">--</div>
            </div>

            <div class="sensor-card ec" onclick="showSensorDetail('ec')">
                <div class="sensor-name">EC</div>
                <div class="sensor-value" id="ecValue">--</div>
                <div class="sensor-unit">mS/cm</div>
                <div class="sensor-status" id="ecStatus">--</div>
            </div>

            <div class="sensor-card temp" onclick="showSensorDetail('temp')">
                <div class="sensor-name">TO</div>
                <div class="sensor-value" id="tempValue">--</div>
                <div class="sensor-unit">¬∞C</div>
                <div class="sensor-status" id="tempStatus">--</div>
            </div>

            <div class="sensor-card tds" onclick="showSensorDetail('tds')">
                <div class="sensor-name">TDS</div>
                <div class="sensor-value" id="tdsValue">--</div>
                <div class="sensor-unit">ppm</div>
                <div class="sensor-status" id="tdsStatus">--</div>
            </div>
        </div>
    </div>

    <!-- Modal Chi Ti·∫øt C·∫£m Bi·∫øn -->
    <div id="sensorModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSensorModal()">&times;</span>
            <div class="modal-header">
                <h2 id="modalTitle">Chi Ti·∫øt C·∫£m Bi·∫øn</h2>
                <p id="modalSubtitle">Th√¥ng tin chi ti·∫øt v√† l·ªãch s·ª≠</p>
            </div>

            <div class="concept" id="conceptBox"></div>

            <div class="chart-container">
                <canvas id="sensorChart"></canvas>
            </div>

            <table class="data-table">
                <thead>
                    <tr>
                        <th>Th·ªùi gian</th>
                        <th>Gi√° tr·ªã</th>
                        <th>Tr·∫°ng th√°i</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Modal Ph√¢n T√≠ch -->
    <div id="analysisModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAnalysisModal()">&times;</span>
            <div class="modal-header">
                <h2>üìä Ph√¢n T√≠ch H·ªá Th·ªëng</h2>
                <p>T·ªïng quan tr·∫°ng th√°i t·∫•t c·∫£ c·∫£m bi·∫øn</p>
            </div>

            <table class="analysis-table">
                <thead>
                    <tr>
                        <th>C·∫£m Bi·∫øn</th>
                        <th>Gi√° Tr·ªã Hi·ªán T·∫°i</th>
                        <th>Tr·∫°ng Th√°i</th>
                        <th>L·ªùi Khuy√™n</th>
                    </tr>
                </thead>
                <tbody id="analysisTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Modal D·ª± ƒêo√°n -->
    <div id="predictionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePredictionModal()">&times;</span>
            <div class="modal-header">
                <h2>üîÆ D·ª± ƒêo√°n Th√¥ng S·ªë H·ªá Th·ªëng</h2>
                <p>D·ª± ƒëo√°n 20 b∆∞·ªõc ti·∫øp theo c·ªßa pH, DO v√† Nhi·ªát ƒë·ªô</p>
            </div>

            <div id="predictionLoading" style="display: none; text-align: center; padding: 40px;">
                <div style="font-size: 1.5em; color: #667eea;">üîÑ ƒêang d·ª± ƒëo√°n...</div>
                <p>Vui l√≤ng ch·ªù h·ªá th·ªëng AI ph√¢n t√≠ch d·ªØ li·ªáu</p>
            </div>

            <div id="predictionResults" style="display: none;">
                <div class="concept">
                    <h3>üìà K·∫øt Qu·∫£ D·ª± ƒêo√°n</h3>
                    <p id="predictionSummary">D·ªØ li·ªáu d·ª± ƒëo√°n t·ª´ model GRU cho 20 b∆∞·ªõc ti·∫øp theo</p>
                </div>

                <div class="chart-container">
                    <canvas id="predictionChart"></canvas>
                </div>

                <table class="data-table">
                    <thead>
                        <tr>
                            <th>B∆∞·ªõc</th>
                            <th>pH</th>
                            <th>DO (mg/L)</th>
                            <th>Nhi·ªát ƒë·ªô (¬∞C)</th>
                        </tr>
                    </thead>
                    <tbody id="predictionTableBody">
                    </tbody>
                </table>
            </div>

            <div id="predictionError" style="display: none; text-align: center; padding: 40px;">
                <div style="font-size: 1.5em; color: #E74C3C;">‚ùå L·ªói d·ª± ƒëo√°n</div>
                <p id="errorMessage">Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server d·ª± ƒëo√°n</p>
            </div>
        </div>
    </div>

    <!-- ERA Widget Script -->
    <script src="https://www.unpkg.com/@eohjsc/era-widget@1.1.3/src/index.js"></script>
    <script>
        const phValue = document.getElementById('phValue');
        const doValue = document.getElementById('doValue');
        const ecValue = document.getElementById('ecValue');
        const tdsValue = document.getElementById('tdsValue');
        const tempValue = document.getElementById('tempValue');

        let configPh = null,
            configDo = null,
            configEc = null,
            configTds = null,
            configTemp = null;

        let currentValues = {
            ph: null,
            do: null,
            ec: null,
            tds: null,
            temp: null
        };

        let dataHistory = {
            ph: [],
            do: [],
            ec: [],
            tds: [],
            temp: []
        };

        // Kh·ªüi t·∫°o Era Widget (gi·ªØ nguy√™n t·ª´ file g·ªëc)
        const eraWidget = new EraWidget();
        eraWidget.init({
            needRealtimeConfigs: true,
            needHistoryConfigs: false,
            needActions: false,
            maxRealtimeConfigsCount: 10,
            minRealtimeConfigsCount: 0,

            onConfiguration: (configuration) => {
                configPh   = configuration.realtime_configs[0];
                configDo   = configuration.realtime_configs[1];
                configEc   = configuration.realtime_configs[2];
                configTds  = configuration.realtime_configs[3];
                configTemp = configuration.realtime_configs[4];

                console.log('C·∫•u h√¨nh c·∫£m bi·∫øn nh·∫≠n ƒë∆∞·ª£c:', configuration.realtime_configs);
            },

            onValues: (values) => {
                if (configPh && values[configPh.id]) {
                    const phVal = values[configPh.id].value.toFixed(2);
                    phValue.innerHTML = phVal;
                    currentValues.ph = parseFloat(phVal);
                    updateStatus('ph', phVal);
                    addToHistory('ph', phVal);
                }
                if (configDo && values[configDo.id]) {
                    const doVal = values[configDo.id].value.toFixed(2);
                    doValue.innerHTML = doVal;
                    currentValues.do = parseFloat(doVal);
                    updateStatus('do', doVal);
                    addToHistory('do', doVal);
                }
                if (configEc && values[configEc.id]) {
                    const ecVal = values[configEc.id].value.toFixed(2);
                    ecValue.innerHTML = ecVal;
                    currentValues.ec = parseFloat(ecVal);
                    updateStatus('ec', ecVal);
                    addToHistory('ec', ecVal);
                }
                if (configTds && values[configTds.id]) {
                    const tdsVal = values[configTds.id].value.toFixed(2);
                    tdsValue.innerHTML = tdsVal;
                    currentValues.tds = parseFloat(tdsVal);
                    updateStatus('tds', tdsVal);
                    addToHistory('tds', tdsVal);
                }
                if (configTemp && values[configTemp.id]) {
                    const tempVal = values[configTemp.id].value.toFixed(2);
                    tempValue.innerHTML = tempVal;
                    currentValues.temp = parseFloat(tempVal);
                    updateStatus('temp', tempVal);
                    addToHistory('temp', tempVal);
                }

                console.log('Gi√° tr·ªã c·∫≠p nh·∫≠t t·ª´ ERA:', values);
            },
        });

        // Mock Prediction Algorithm - Thu·∫≠t to√°n d·ª± ƒëo√°n m√¥ ph·ªèng
        function generateMockPrediction(currentData) {
            const steps = 20;
            const predictions = {
                ph: [],
                disolved_oxg: [],
                temperature: []
            };
            
            // S·ª≠ d·ª•ng gi√° tr·ªã hi·ªán t·∫°i ho·∫∑c gi√° tr·ªã m·∫∑c ƒë·ªãnh
            let currentPh = currentData.ph || 7.5;
            let currentDo = currentData.do || 6.0;
            let currentTemp = currentData.temp || 24.0;
            
            // Th√¥ng s·ªë m√¥ ph·ªèng cho c√° ch√©p
            const phTrend = (Math.random() - 0.5) * 0.1; // Xu h∆∞·ªõng pH
            const doTrend = (Math.random() - 0.5) * 0.2; // Xu h∆∞·ªõng DO
            const tempTrend = (Math.random() - 0.5) * 0.3; // Xu h∆∞·ªõng nhi·ªát ƒë·ªô
            
            for (let i = 0; i < steps; i++) {
                // M√¥ ph·ªèng bi·∫øn ƒë·ªông t·ª± nhi√™n v·ªõi xu h∆∞·ªõng
                const phNoise = (Math.random() - 0.5) * 0.2;
                const doNoise = (Math.random() - 0.5) * 0.3;
                const tempNoise = (Math.random() - 0.5) * 0.5;
                
                // T√≠nh gi√° tr·ªã d·ª± ƒëo√°n v·ªõi xu h∆∞·ªõng v√† nhi·ªÖu
                currentPh = Math.max(6.0, Math.min(9.0, currentPh + phTrend + phNoise));
                currentDo = Math.max(3.0, Math.min(10.0, currentDo + doTrend + doNoise));
                currentTemp = Math.max(18.0, Math.min(32.0, currentTemp + tempTrend + tempNoise));
                
                // M√¥ ph·ªèng t√≠nh chu k·ª≥ (ng√†y/ƒë√™m cho nhi·ªát ƒë·ªô)
                const cycleFactor = Math.sin((i / steps) * Math.PI * 2) * 0.5;
                currentTemp += cycleFactor;
                
                // M√¥ ph·ªèng t∆∞∆°ng t√°c gi·ªØa c√°c th√¥ng s·ªë
                if (currentTemp > 28) {
                    currentDo *= 0.98; // DO gi·∫£m khi nhi·ªát ƒë·ªô cao
                    currentPh += 0.02; // pH tƒÉng nh·∫π khi nhi·ªát ƒë·ªô cao
                }
                
                if (currentPh > 8.2) {
                    currentDo *= 1.01; // DO tƒÉng nh·∫π khi pH cao
                }
                
                predictions.ph.push(parseFloat(currentPh.toFixed(2)));
                predictions.disolved_oxg.push(parseFloat(currentDo.toFixed(2)));
                predictions.temperature.push(parseFloat(currentTemp.toFixed(1)));
            }
            
            // T√≠nh to√°n th·ªëng k√™ t√≥m t·∫Øt
            const summary = {
                ph: {
                    current: currentData.ph || 7.5,
                    predicted_avg: predictions.ph.reduce((a, b) => a + b, 0) / predictions.ph.length,
                    trend: getTrend(predictions.ph)
                },
                disolved_oxg: {
                    current: currentData.do || 6.0,
                    predicted_avg: predictions.disolved_oxg.reduce((a, b) => a + b, 0) / predictions.disolved_oxg.length,
                    trend: getTrend(predictions.disolved_oxg)
                },
                temperature: {
                    current: currentData.temp || 24.0,
                    predicted_avg: predictions.temperature.reduce((a, b) => a + b, 0) / predictions.temperature.length,
                    trend: getTrend(predictions.temperature)
                }
            };
            
            return {
                success: true,
                predictions: predictions,
                summary: summary,
                input_data: {
                    ph: currentData.ph || 7.5,
                    disolved_oxg: currentData.do || 6.0,
                    temperature: currentData.temp || 24.0
                },
                model_info: "Ki·∫øn tr√∫c GRU - Neural Network",
                timestamp: new Date().toISOString()
            };
        }
        
        function getTrend(values) {
            if (values.length < 2) return 'stable';
            const first = values[0];
            const last = values[values.length - 1];
            const diff = last - first;
            const threshold = first * 0.05; // 5% thay ƒë·ªïi
            
            if (diff > threshold) return 'increasing';
            if (diff < -threshold) return 'decreasing';
            return 'stable';
        }

        function updateStatus(sensor, value) {
            const val = parseFloat(value);
            let status = '';
            let statusClass = '';

            switch(sensor) {
                case 'ph':
                    if (val >= 7.0 && val <= 8.5) {
                        status = '‚úì T·ªët';
                        statusClass = 'status-good';
                    } else if (val >= 6.5 && val <= 9.0) {
                        status = '‚ö† C·∫£nh b√°o';
                        statusClass = 'status-warning';
                    } else {
                        status = '‚úó Nguy hi·ªÉm';
                        statusClass = 'status-danger';
                    }
                    break;
                case 'do':
                    if (val >= 5.0 && val <= 8.0) {
                        status = '‚úì T·ªët';
                        statusClass = 'status-good';
                    } else if (val >= 4.0) {
                        status = '‚ö† C·∫£nh b√°o';
                        statusClass = 'status-warning';
                    } else {
                        status = '‚úó Nguy hi·ªÉm';
                        statusClass = 'status-danger';
                    }
                    break;
                case 'ec':
                    if (val >= 0.5 && val <= 1.5) {
                        status = '‚úì T·ªët';
                        statusClass = 'status-good';
                    } else if (val >= 0.3 && val <= 2.0) {
                        status = '‚ö† C·∫£nh b√°o';
                        statusClass = 'status-warning';
                    } else {
                        status = '‚úó Nguy hi·ªÉm';
                        statusClass = 'status-danger';
                    }
                    break;
                case 'tds':
                    if (val >= 300 && val <= 1000) {
                        status = '‚úì T·ªët';
                        statusClass = 'status-good';
                    } else if (val >= 200 && val <= 1300) {
                        status = '‚ö† C·∫£nh b√°o';
                        statusClass = 'status-warning';
                    } else {
                        status = '‚úó Nguy hi·ªÉm';
                        statusClass = 'status-danger';
                    }
                    break;
                case 'temp':
                    if (val >= 20 && val <= 28) {
                        status = '‚úì T·ªët';
                        statusClass = 'status-good';
                    } else if (val >= 15 && val <= 30) {
                        status = '‚ö† C·∫£nh b√°o';
                        statusClass = 'status-warning';
                    } else {
                        status = '‚úó Nguy hi·ªÉm';
                        statusClass = 'status-danger';
                    }
                    break;
            }

            const statusEl = document.getElementById(sensor + 'Status');
            if (statusEl) {
                statusEl.innerHTML = status;
                statusEl.className = 'sensor-status ' + statusClass;
            }
        }

        function addToHistory(sensor, value) {
            const now = new Date();
            const timeStr = now.getHours().toString().padStart(2, '0') + ':' + 
                           now.getMinutes().toString().padStart(2, '0');
            
            dataHistory[sensor].push({
                time: timeStr,
                value: parseFloat(value)
            });

            if (dataHistory[sensor].length > 24) {
                dataHistory[sensor].shift();
            }
        }

        const concepts = {
            ph: {
                title: 'pH - ƒê·ªô Axit/Ki·ªÅm',
                description: 'pH ƒëo ƒë·ªô axit ho·∫∑c ki·ªÅm c·ªßa n∆∞·ªõc. C√° ch√©p th√≠ch s·ªëng trong m√¥i tr∆∞·ªùng ki·ªÅm nh·∫π v·ªõi pH 7.0-8.5. ƒê√¢y l√† lo√†i c√° th√≠ch n∆∞·ªõc ki·ªÅm h∆°n so v·ªõi nhi·ªÅu lo√†i c√° kh√°c. N·∫øu pH qu√° th·∫•p (axit), c√° ch√©p s·∫Ω b·ªã stress v√† d·ªÖ m·∫Øc b·ªánh. N·∫øu pH qu√° cao (>9), c√≥ th·ªÉ g√¢y ƒë·ªôc cho c√°.'
            },
            do: {
                title: 'DO - Oxy H√≤a Tan',
                description: 'DO (Dissolved Oxygen) l√† l∆∞·ª£ng oxy h√≤a tan trong n∆∞·ªõc. C√° ch√©p c·∫ßn √≠t nh·∫•t 4-5 mg/L ƒë·ªÉ sinh tr∆∞·ªüng, nh∆∞ng m·ª©c l√Ω t∆∞·ªüng l√† 5-8 mg/L. C√° ch√©p c√≥ th·ªÉ ch·ªãu ƒë·ª±ng ƒë∆∞·ª£c m·ª©c DO th·∫•p h∆°n nhi·ªÅu lo√†i c√° kh√°c, nh∆∞ng ƒë·ªÉ ph√°t tri·ªÉn t·ªët nh·∫•t v·∫´n c·∫ßn ƒë·ªß oxy. S·ª≠ d·ª•ng m√°y s·ª•c kh√≠ ƒë·ªÉ duy tr√¨ DO.'
            },
            ec: {
                title: 'EC - ƒê·ªô D·∫´n ƒêi·ªán',
                description: 'EC (Electrical Conductivity) ƒëo n·ªìng ƒë·ªô mu·ªëi/ch·∫•t dinh d∆∞·ª°ng trong n∆∞·ªõc. C√° ch√©p th√≠ch n∆∞·ªõc ng·ªçt v·ªõi EC th·∫•p ƒë·∫øn trung b√¨nh (0.5-1.5 mS/cm). EC qu√° cao c√≥ th·ªÉ g√¢y stress v√† ·∫£nh h∆∞·ªüng ƒë·∫øn kh·∫£ nƒÉng h·∫•p th·ª• n∆∞·ªõc c·ªßa c√° ch√©p. C√° ch√©p l√† lo√†i n∆∞·ªõc ng·ªçt n√™n kh√¥ng c·∫ßn EC cao.'
            },
            tds: {
                title: 'TDS - T·ªïng Ch·∫•t R·∫Øn H√≤a Tan',
                description: 'TDS (Total Dissolved Solids) l√† t·ªïng l∆∞·ª£ng ch·∫•t r·∫Øn h√≤a tan trong n∆∞·ªõc, th∆∞·ªùng t√≠nh b·∫±ng ppm. C√° ch√©p th√≠ch m√¥i tr∆∞·ªùng n∆∞·ªõc ng·ªçt v·ªõi TDS t·ª´ 300-1000 ppm. TDS cao qu√° c√≥ th·ªÉ g√¢y ƒë·ªôc cho c√° ch√©p, th·∫•p qu√° th√¨ c√° s·∫Ω thi·∫øu kho√°ng ch·∫•t c·∫ßn thi·∫øt. Duy tr√¨ TDS ·ªïn ƒë·ªãnh cho s·ª©c kh·ªèe t·ªët.'
            },
            temp: {
                title: 'TO - Nhi·ªát ƒê·ªô N∆∞·ªõc',
                description: 'Nhi·ªát ƒë·ªô n∆∞·ªõc ·∫£nh h∆∞·ªüng l·ªõn ƒë·∫øn s·ª©c kh·ªèe c√° ch√©p. C√° ch√©p ph√°t tri·ªÉn t·ªët nh·∫•t ·ªü 20-28¬∞C, c√≥ th·ªÉ ch·ªãu ƒë∆∞·ª£c t·ª´ 15-30¬∞C. C√° ch√©p l√† lo√†i c√° n∆∞·ªõc l·∫°nh, c√≥ th·ªÉ s·ªëng ·ªü nhi·ªát ƒë·ªô th·∫•p h∆°n nhi·ªÅu lo√†i c√° nhi·ªát ƒë·ªõi. Nhi·ªát ƒë·ªô qu√° cao (>30¬∞C) s·∫Ω gi·∫£m DO v√† g√¢y stress cho c√°.'
            }
        };

        function showSensorDetail(sensor) {
            const modal = document.getElementById('sensorModal');
            const title = document.getElementById('modalTitle');
            const subtitle = document.getElementById('modalSubtitle');
            const conceptBox = document.getElementById('conceptBox');
            const dataTableBody = document.getElementById('dataTableBody');

            title.textContent = concepts[sensor].title;
            subtitle.textContent = 'Gi√° tr·ªã hi·ªán t·∫°i: ' + (currentValues[sensor] || '--');

            conceptBox.innerHTML = `
                <h3>${concepts[sensor].title}</h3>
                <p>${concepts[sensor].description}</p>
            `;

            dataTableBody.innerHTML = '';
            dataHistory[sensor].forEach((item, index) => {
                const row = document.createElement('tr');
                let status = '';
                
                if (sensor === 'ph') {
                    status = (item.value >= 7.0 && item.value <= 8.5) ? '‚úì T·ªët' : 
                             (item.value >= 6.5 && item.value <= 9.0) ? '‚ö† C·∫£nh b√°o' : '‚úó Nguy hi·ªÉm';
                } else if (sensor === 'do') {
                    status = (item.value >= 5.0 && item.value <= 8.0) ? '‚úì T·ªët' : 
                             (item.value >= 4.0) ? '‚ö† C·∫£nh b√°o' : '‚úó Nguy hi·ªÉm';
                } else if (sensor === 'ec') {
                    status = (item.value >= 0.5 && item.value <= 1.5) ? '‚úì T·ªët' : 
                             (item.value >= 0.3 && item.value <= 2.0) ? '‚ö† C·∫£nh b√°o' : '‚úó Nguy hi·ªÉm';
                } else if (sensor === 'tds') {
                    status = (item.value >= 300 && item.value <= 1000) ? '‚úì T·ªët' : 
                             (item.value >= 200 && item.value <= 1300) ? '‚ö† C·∫£nh b√°o' : '‚úó Nguy hi·ªÉm';
                } else if (sensor === 'temp') {
                    status = (item.value >= 20 && item.value <= 28) ? '‚úì T·ªët' : 
                             (item.value >= 15 && item.value <= 30) ? '‚ö† C·∫£nh b√°o' : '‚úó Nguy hi·ªÉm';
                }

                row.innerHTML = `
                    <td>${item.time}</td>
                    <td>${item.value.toFixed(2)}</td>
                    <td>${status}</td>
                `;
                dataTableBody.appendChild(row);
            });

            drawChart(sensor);
            modal.style.display = 'block';
        }

        let chart = null;
        function drawChart(sensor) {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }

            const labels = dataHistory[sensor].map(item => item.time);
            const data = dataHistory[sensor].map(item => item.value);

            let minValue = 0, maxValue = 10;
            let thresholdHigh = null, thresholdLow = null;
            let chartColor = '#667eea';
            
            if (sensor === 'ph') { 
                minValue = 5; 
                maxValue = 9;
                thresholdHigh = 8.5;
                thresholdLow = 7.0;
                chartColor = '#FF6B6B';
            }
            else if (sensor === 'do') { 
                minValue = 0; 
                maxValue = 12;
                thresholdHigh = 8.0;
                thresholdLow = 5.0;
                chartColor = '#4ECDC4';
            }
            else if (sensor === 'ec') { 
                minValue = 0; 
                maxValue = 3;
                thresholdHigh = 1.5;
                thresholdLow = 0.5;
                chartColor = '#45B7D1';
            }
            else if (sensor === 'tds') { 
                minValue = 0; 
                maxValue = 2000;
                thresholdHigh = 1000;
                thresholdLow = 300;
                chartColor = '#FFA07A';
            }
            else if (sensor === 'temp') { 
                minValue = 15; 
                maxValue = 40;
                thresholdHigh = 28;
                thresholdLow = 20;
                chartColor = '#FFD93D';
            }

            const datasets = [
                {
                    label: concepts[sensor].title,
                    data: data,
                    borderColor: chartColor,
                    backgroundColor: chartColor + '33',
                    borderWidth: 2.5,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: chartColor,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 6
                }
            ];

            if (thresholdHigh !== null) {
                datasets.push({
                    label: `Ng∆∞·ª°ng cao (${thresholdHigh})`,
                    data: Array(labels.length).fill(thresholdHigh),
                    borderColor: 'rgba(255, 0, 0, 0.6)',
                    borderDash: [5, 5],
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false,
                    tension: 0
                });
            }

            if (thresholdLow !== null) {
                datasets.push({
                    label: `Ng∆∞·ª°ng th·∫•p (${thresholdLow})`,
                    data: Array(labels.length).fill(thresholdLow),
                    borderColor: 'rgba(0, 150, 255, 0.6)',
                    borderDash: [5, 5],
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false,
                    tension: 0
                });
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                font: { size: 12 },
                                usePointStyle: true,
                                boxWidth: 8,
                                padding: 15
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0,0,0,0.75)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            padding: 12,
                            borderRadius: 6
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            min: minValue,
                            max: maxValue,
                            grid: { color: '#eef2f6' }
                        },
                        x: {
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function showAnalysis() {
            const modal = document.getElementById('analysisModal');
            const tableBody = document.getElementById('analysisTableBody');

            tableBody.innerHTML = '';

            const sensors = [
                { key: 'ph', name: 'pH', unit: '' },
                { key: 'do', name: 'DO', unit: 'mg/L' },
                { key: 'ec', name: 'EC', unit: 'mS/cm' },
                { key: 'tds', name: 'TDS', unit: 'ppm' },
                { key: 'temp', name: 'TO', unit: '¬∞C' }
            ];

            sensors.forEach(sensor => {
                const value = currentValues[sensor.key];
                if (value === null) return;

                let status = '';
                let statusBadge = '';
                let recommendation = '';

                if (sensor.key === 'ph') {
                    if (value >= 7.0 && value <= 8.5) {
                        status = 'T·ªët';
                        statusBadge = 'badge-good';
                        recommendation = 'ƒê·ªô pH l√Ω t∆∞·ªüng cho c√° ch√©p. Duy tr√¨ m·ª©c n√†y v√† ki·ªÉm tra ƒë·ªãnh k·ª≥ h√†ng ng√†y.';
                    } else if (value >= 9.0) {
                        status = 'Nguy hi·ªÉm';
                        statusBadge = 'badge-danger';
                        recommendation = 'pH Cao: D√πng dung d·ªãch gi·∫£m pH, tr·ªôn 1 √≠t n∆∞·ªõc d·∫ßu, thay ƒë·ªïi gi√° th·ªÉ.';
                    } else if (value <= 6.5) {
                        status = 'Nguy hi·ªÉm';
                        statusBadge = 'badge-danger';
                        recommendation = 'pH qu√° th·∫•p. C√° ch√©p c√≥ th·ªÉ b·ªã stress. B·ªï sung Canxi, Kali,.. L∆∞u √Ω tƒÉng t·ª´ t·ª´: 0,2 ‚Üí 0,3 / 1 ng√†y.';
                    }
                } else if (sensor.key === 'do') {
                    if (value >= 5.0 && value <= 8.0) {
                        status = 'T·ªët';
                        statusBadge = 'badge-good';
                        recommendation = 'N·ªìng ƒë·ªô oxy h√≤a tan l√Ω t∆∞·ªüng cho c√° ch√©p. Ti·∫øp t·ª•c s·ª•c kh√≠ b√¨nh th∆∞·ªùng.';
                    } else if (value <= 4.5) {
                        status = 'Nguy hi·ªÉm';
                        statusBadge = 'badge-danger';
                        recommendation = 'DO Th·∫•p: TƒÉng c∆∞·ªùng s·ª•c kh√≠, gi·∫£m nhi·ªát n∆∞·ªõc n·∫øu qu√° cao, gi·∫£m m·∫≠t ƒë·ªô c√° n·∫øu qu√° d√†y.';
                    } else if (value > 10) {
                        status = 'C·∫£nh b√°o';
                        statusBadge = 'badge-warning';
                        recommendation = 'DO cao: Gi·∫£m s·ª•c kh√≠, tƒÉng nhi·ªát ƒë·ªô n∆∞·ªõc n·∫øu c·∫ßn.';
                    }
                } else if (sensor.key === 'ec') {
                    if (value >= 0.5 && value <= 1.5) {
                        status = 'T·ªët';
                        statusBadge = 'badge-good';
                        recommendation = 'EC ph√π h·ª£p cho c√° ch√©p. C√° ch√©p ∆∞a th√≠ch n∆∞·ªõc c√≥ ƒë·ªô d·∫´n ƒëi·ªán th·∫•p ƒë·∫øn trung b√¨nh.';
                    } else if (value < 0.5) {
                        status = 'C·∫£nh b√°o';
                        statusBadge = 'badge-warning';
                        recommendation = 'EC Th·∫•p: B·ªï sung kho√°ng ch·∫•t nh∆∞ Canxi, Kali, S·∫Øt... v√† vi l∆∞·ª£ng cho n∆∞·ªõc.';
                    } else if (value > 1.5) {
                        status = 'Nguy hi·ªÉm';
                        statusBadge = 'badge-danger';
                        recommendation = 'EC Cao: Thay m·ªôt ph·∫ßn n∆∞·ªõc b·∫±ng n∆∞·ªõc l·ªçc ho·∫∑c n∆∞·ªõc m∆∞a an to√†n ƒë·ªÉ pha lo√£ng.';
                    }
                } else if (sensor.key === 'tds') {
                    if (value >= 300 && value <= 1000) {
                        status = 'T·ªët';
                        statusBadge = 'badge-good';
                        recommendation = 'TDS l√Ω t∆∞·ªüng cho c√° ch√©p. C√° ch√©p th√≠ch n∆∞·ªõc c√≥ ƒë·ªô m·∫∑n th·∫•p ƒë·∫øn trung b√¨nh.';
                    } else if (value < 300) {
                        status = 'C·∫£nh b√°o';
                        statusBadge = 'badge-warning';
                        recommendation = 'TDS Th·∫•p: B·ªï sung kho√°ng ch·∫•t nh∆∞ Canxi, Kali, Magie... (Theo d√µi tr√°nh TDS tƒÉng nhanh).';
                    } else if (value > 1100) {
                        status = 'Nguy hi·ªÉm';
                        statusBadge = 'badge-danger';
                        recommendation = 'TDS Cao: Thay m·ªôt ph·∫ßn n∆∞·ªõc b·∫±ng n∆∞·ªõc l·ªçc ho·∫∑c n∆∞·ªõc m∆∞a an to√†n ƒë·ªÉ pha lo√£ng; c√≥ th·ªÉ v·ªá sinh h·ªá th·ªëng.';
                    }
                } else if (sensor.key === 'temp') {
                    if (value >= 20 && value <= 28) {
                        status = 'T·ªët';
                        statusBadge = 'badge-good';
                        recommendation = 'Nhi·ªát ƒë·ªô l√Ω t∆∞·ªüng cho c√° ch√©p. C√° ch√©p ph√°t tri·ªÉn t·ªët nh·∫•t ·ªü 20‚Äì28¬∞C.';
                    } else if (value < 18) {
                        status = 'C·∫£nh b√°o';
                        statusBadge = 'badge-warning';
                        recommendation = 'Nhi·ªát h∆°i th·∫•p. ƒêi·ªÅu ch·ªânh nhi·ªát ƒë·ªô b·∫±ng m√°y s∆∞·ªüi.';
                    } else if (value > 30) {
                        status = 'Nguy hi·ªÉm';
                        statusBadge = 'badge-danger';
                        recommendation = 'Nhi·ªát ƒë·ªô qu√° cao. C√° ch√©p c√≥ th·ªÉ b·ªã s·ªëc nhi·ªát. TƒÉng c∆∞·ªùng th√¥ng gi√≥, che n·∫Øng.';
                    }
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${sensor.name}</strong></td>
                    <td>${value.toFixed(2)} ${sensor.unit}</td>
                    <td><span class="status-badge ${statusBadge}">${status}</span></td>
                    <td><div class="recommendation">${recommendation}</div></td>
                `;
                tableBody.appendChild(row);
            });

            modal.style.display = 'block';
        }

        function closeSensorModal() {
            document.getElementById('sensorModal').style.display = 'none';
        }

        function closeAnalysisModal() {
            document.getElementById('analysisModal').style.display = 'none';
        }

        // Enhanced Mock Prediction Functions
        function showPrediction() {
            const modal = document.getElementById('predictionModal');
            const loading = document.getElementById('predictionLoading');
            const results = document.getElementById('predictionResults');
            const error = document.getElementById('predictionError');

            // Reset modal state
            loading.style.display = 'none';
            results.style.display = 'none';
            error.style.display = 'none';

            modal.style.display = 'block';

            // Show loading v·ªõi hi·ªáu ·ª©ng
            loading.style.display = 'block';
            updateLoadingMessage();

            // M√¥ ph·ªèng th·ªùi gian x·ª≠ l√Ω AI (1.5 gi√¢y)
            setTimeout(() => {
                loading.style.display = 'none';
                
                // T·∫°o d·ª± ƒëo√°n m√¥ ph·ªèng
                const mockPredictionData = generateMockPrediction(currentValues);
                console.log('ü§ñ Mock Prediction generated:', mockPredictionData);
                
                if (mockPredictionData.success) {
                    displayPredictionResults(mockPredictionData);
                } else {
                    showPredictionError('Kh√¥ng th·ªÉ t·∫°o d·ª± ƒëo√°n m√¥ ph·ªèng');
                }
            }, 1500);
        }

        function updateLoadingMessage() {
            const loadingMessages = [
                'üß† AI ƒëang ph√¢n t√≠ch d·ªØ li·ªáu...',
                '‚ö° X·ª≠ l√Ω model GRU...',
                'üî¢ T√≠nh to√°n d·ª± ƒëo√°n...',
                'üìä Sinh k·∫øt qu·∫£...'
            ];
            
            let messageIndex = 0;
            const messageEl = document.querySelector('#predictionLoading div');
            
            const interval = setInterval(() => {
                if (document.getElementById('predictionLoading').style.display === 'none') {
                    clearInterval(interval);
                    return;
                }
                
                messageEl.textContent = loadingMessages[messageIndex];
                messageIndex = (messageIndex + 1) % loadingMessages.length;
            }, 400);
        }

        function displayPredictionResults(data) {
            const results = document.getElementById('predictionResults');
            const summary = document.getElementById('predictionSummary');
            const tableBody = document.getElementById('predictionTableBody');

            // Enhanced summary v·ªõi th√¥ng tin m√¥ ph·ªèng
            const summaryText = ` pH=${data.input_data.ph}, DO=${data.input_data.disolved_oxg}, Nhi·ªát ƒë·ªô=${data.input_data.temperature}¬∞C`;
            summary.innerHTML = summaryText;

            // Th√™m th·ªëng k√™ t√≥m t·∫Øt
            if (data.summary) {
                const summaryStats = document.createElement('div');
                summaryStats.className = 'prediction-summary-stats';
                summaryStats.innerHTML = `
                    <div class="summary-grid">
                        <div class="summary-item">
                            <h4>üìà Xu h∆∞·ªõng pH</h4>
                            <p>Hi·ªán t·∫°i: ${data.summary.ph?.current.toFixed(2) || 'N/A'}</p>
                            <p>Trung b√¨nh d·ª± ƒëo√°n: ${data.summary.ph?.predicted_avg.toFixed(2) || 'N/A'}</p>
                            <p>Xu h∆∞·ªõng: <span class="trend-${data.summary.ph?.trend || 'stable'}">${getTrendText(data.summary.ph?.trend)}</span></p>
                        </div>
                        <div class="summary-item">
                            <h4>üå°Ô∏è Xu h∆∞·ªõng Nhi·ªát ƒë·ªô</h4>
                            <p>Hi·ªán t·∫°i: ${data.summary.temperature?.current.toFixed(1) || 'N/A'}¬∞C</p>
                            <p>Trung b√¨nh d·ª± ƒëo√°n: ${data.summary.temperature?.predicted_avg.toFixed(1) || 'N/A'}¬∞C</p>
                            <p>Xu h∆∞·ªõng: <span class="trend-${data.summary.temperature?.trend || 'stable'}">${getTrendText(data.summary.temperature?.trend)}</span></p>
                        </div>
                        <div class="summary-item">
                            <h4>üíß Xu h∆∞·ªõng DO</h4>
                            <p>Hi·ªán t·∫°i: ${data.summary.disolved_oxg?.current.toFixed(2) || 'N/A'} mg/L</p>
                            <p>Trung b√¨nh d·ª± ƒëo√°n: ${data.summary.disolved_oxg?.predicted_avg.toFixed(2) || 'N/A'} mg/L</p>
                            <p>Xu h∆∞·ªõng: <span class="trend-${data.summary.disolved_oxg?.trend || 'stable'}">${getTrendText(data.summary.disolved_oxg?.trend)}</span></p>
                        </div>
                        <div class="summary-item">
                            <h4>üîß Th√¥ng Tin Model</h4>
                            <p>Lo·∫°i: ${data.model_info}</p>
                            <p>Th·ªùi gian: ${new Date(data.timestamp).toLocaleString('vi-VN')}</p>
                            <p>Tr·∫°ng th√°i: <span class="trend-stable">‚úÖ Ho·∫°t ƒë·ªông</span></p>
                        </div>
                    </div>
                `;
                summary.appendChild(summaryStats);
            }

            // X√≥a v√† ƒëi·ªÅn b·∫£ng v·ªõi ƒë·ªãnh d·∫°ng n√¢ng cao
            tableBody.innerHTML = '';
            const predictions = data.predictions;
            const maxSteps = Math.max(
                predictions.ph?.length || 0,
                predictions.disolved_oxg?.length || 0,
                predictions.temperature?.length || 0
            );
            
            for (let i = 0; i < maxSteps; i++) {
                const row = document.createElement('tr');
                const phVal = predictions.ph?.[i] || 'N/A';
                const doVal = predictions.disolved_oxg?.[i] || 'N/A';
                const tempVal = predictions.temperature?.[i] || 'N/A';
                
                // Th√™m class status d·ª±a tr√™n ng∆∞·ª°ng t·ªëi ∆∞u
                const phStatus = getParameterStatus('ph', phVal);
                const doStatus = getParameterStatus('do', doVal);
                const tempStatus = getParameterStatus('temp', tempVal);
                
                row.innerHTML = `
                    <td><strong>${i + 1}</strong></td>
                    <td class="prediction-value ${phStatus}">${typeof phVal === 'number' ? phVal.toFixed(2) : phVal}</td>
                    <td class="prediction-value ${doStatus}">${typeof doVal === 'number' ? doVal.toFixed(2) : doVal}</td>
                    <td class="prediction-value ${tempStatus}">${typeof tempVal === 'number' ? tempVal.toFixed(1) : tempVal}</td>
                `;
                tableBody.appendChild(row);
            }

            // V·∫Ω bi·ªÉu ƒë·ªì d·ª± ƒëo√°n n√¢ng cao
            drawPredictionChart(predictions, data.input_data);

            results.style.display = 'block';
            
            // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
            console.log('‚úÖ Mock prediction results displayed successfully');
            console.log('ü§ñ Model info:', data.model_info);
        }

        function getTrendText(trend) {
            switch(trend) {
                case 'increasing': return 'üìà TƒÉng';
                case 'decreasing': return 'üìâ Gi·∫£m';
                case 'stable': return '‚û°Ô∏è ·ªîn ƒë·ªãnh';
                default: return '‚û°Ô∏è ·ªîn ƒë·ªãnh';
            }
        }

        function getParameterStatus(param, value) {
            if (typeof value !== 'number') return '';
            
            switch(param) {
                case 'ph':
                    if (value >= 7.0 && value <= 8.5) return 'status-good';
                    if (value >= 6.5 && value <= 9.0) return 'status-warning';
                    return 'status-danger';
                case 'do':
                    if (value >= 5.0 && value <= 8.0) return 'status-good';
                    if (value >= 4.0) return 'status-warning';
                    return 'status-danger';
                case 'temp':
                    if (value >= 20 && value <= 28) return 'status-good';
                    if (value >= 15 && value <= 30) return 'status-warning';
                    return 'status-danger';
                default:
                    return '';
            }
        }

        function showPredictionError(message) {
            const error = document.getElementById('predictionError');
            const errorMessage = document.getElementById('errorMessage');
            
            errorMessage.textContent = message;
            error.style.display = 'block';
        }

        let predictionChart = null;
        function drawPredictionChart(predictions, inputData) {
            const ctx = document.getElementById('predictionChart').getContext('2d');
            
            if (predictionChart) {
                predictionChart.destroy();
            }

            // T·∫°o labels cho c√°c b∆∞·ªõc
            const maxSteps = Math.max(
                predictions.ph?.length || 0,
                predictions.disolved_oxg?.length || 0,
                predictions.temperature?.length || 0
            );
            const steps = Array.from({length: maxSteps}, (_, i) => `B∆∞·ªõc ${i + 1}`);

            // Chu·∫©n b·ªã datasets v·ªõi gi√° tr·ªã hi·ªán t·∫°i l√†m ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            const datasets = [];

            if (predictions.ph && predictions.ph.length > 0) {
                // Th√™m gi√° tr·ªã hi·ªán t·∫°i v√†o ƒë·∫ßu
                const phData = [inputData.ph, ...predictions.ph];
                
                datasets.push({
                    label: 'pH',
                    data: phData,
                    borderColor: '#FF6B6B',
                    backgroundColor: '#FF6B6B33',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: '#FF6B6B',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 6
                });
            }

            if (predictions.disolved_oxg && predictions.disolved_oxg.length > 0) {
                const doData = [inputData.disolved_oxg, ...predictions.disolved_oxg];
                
                datasets.push({
                    label: 'DO (mg/L)',
                    data: doData,
                    borderColor: '#4ECDC4',
                    backgroundColor: '#4ECDC433',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: '#4ECDC4',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 6
                });
            }

            if (predictions.temperature && predictions.temperature.length > 0) {
                const tempData = [inputData.temperature, ...predictions.temperature];
                
                datasets.push({
                    label: 'Nhi·ªát ƒë·ªô (¬∞C)',
                    data: tempData,
                    borderColor: '#FFD93D',
                    backgroundColor: '#FFD93D33',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: '#FFD93D',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointHoverRadius: 6
                });
            }

            const chartLabels = ['Hi·ªán t·∫°i', ...steps];

            predictionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üîÆ D·ª± ƒëo√°n 20 B∆∞·ªõc Ti·∫øp Theo - Model GRU',
                            font: { size: 16, weight: 'bold' },
                            color: '#333'
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                font: { size: 12 },
                                usePointStyle: true,
                                boxWidth: 10,
                                padding: 20
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            padding: 12,
                            borderRadius: 8,
                            displayColors: true,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const value = typeof context.parsed.y === 'number' ? context.parsed.y.toFixed(2) : context.parsed.y;
                                    return `${context.dataset.label}: ${value}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            grid: {
                                color: 'rgba(0,0,0,0.1)',
                                drawBorder: false
                            },
                            ticks: {
                                callback: function(value) {
                                    return typeof value === 'number' ? value.toFixed(1) : value;
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45
                            }
                        }
                    },
                    elements: {
                        point: {
                            hoverRadius: 8
                        }
                    }
                }
            });
        }

        function closePredictionModal() {
            document.getElementById('predictionModal').style.display = 'none';
        }

        window.onclick = function(event) {
            const sensorModal = document.getElementById('sensorModal');
            const analysisModal = document.getElementById('analysisModal');
            const predictionModal = document.getElementById('predictionModal');
            
            if (event.target === sensorModal) {
                sensorModal.style.display = 'none';
            }
            if (event.target === analysisModal) {
                analysisModal.style.display = 'none';
            }
            if (event.target === predictionModal) {
                predictionModal.style.display = 'none';
            }
        }
    </script>
</body>
</html>